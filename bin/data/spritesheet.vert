#version 410

layout(location = 0) in vec3 pos; // 오픈프레임웍스에서 각 버텍스 당 추가해 준 위치 데이터가 담김.
layout(location = 3) in vec2 uv; // 오픈프레임웍스에서 각 버텍스 당 추가해 준 uv 좌표 데이터가 담김.

uniform vec2 size; // 오픈프레임웍스에서 쏴준 전체적인 uv좌표값(즉, x 컴포넌트 0~1, y 컴포넌트 0~1 사이의 값)에 곱해줘서 전체 스프라이트시트 텍스쳐 중 하나의 프레임에 해당하는 부분만큼의 uv좌표값으로 변환하는데 사용할 값
uniform vec2 offset; // 위에서 size 로 uv좌표값을 변환한 뒤, 몇번째, 어느 위치의 프레임으로 이동해서 그려줄 것인지 결정할 x방향 및 y방향의 offset값이 담긴 vec2 데이터 (마찬가지로 오픈프레임웍스에서 쏴줌.)
uniform mat4 model; // 캐릭터메쉬 이동도 변환행렬로 처리하기 위해 변환행렬을 전송받는 유니폼 변수를 지정함. -> 이제부터는 모델을 움직이기 위한 변환행렬이라는 의미에서 '모델행렬' 이라고 부를거임.
uniform mat4 view; // 카메라 움직임의 정반대 방향으로 나머지 대상들의 움직임을 조정하는 뷰행렬(카메라 변환행렬)을 전송받는 유니폼 변수
uniform mat4 proj; // 뷰 공간 좌표를 NDC 좌표계를 사용하는 '클립공간'으로 변환하기 위한 '투영행렬'을 전송받는 유니폼 변수 (투영: 3D 공간을 2D 평면에 시각화하는 것)

out vec2 fragUV;

void main() {
  // gl_Position = transform * vec4(pos, 1.0); // 이동행렬이 담긴 유니폼변수 transform 을 곱해줌으로써 이동연산을 처리하도록 셰이더 구조를 변경함.
  // gl_Position = view * model * vec4(pos, 1.0); // 변환행렬 곱셈 순서는 항상 '모델행렬' 먼저, '뷰행렬' 두 번째로 곱해줌! -> 이거를 cpu 단에서 아예 곱해줘서 합쳐버린 다음 전달해준 변환행렬을 '모델뷰행렬' 이라고 함.
  gl_Position = proj * view * model * vec4(pos, 1.0); // 투영행렬은 항상 마지막에 곱해줌

  /*
    아래와 같이,
    기본 버텍스 uv데이터(0 ~ 1 사이의 기본 범위)에
    (0.28, 0.19)에 해당하는 만큼의 값을 곱해줌으로써,
    가로는 0 ~ 0.28, 세로는 0 ~ 0.19 사이의 uv좌표값만 갖도록 uv좌표값 범위를 변환해 줌.

    이렇게 하면, 하나의 프레임 부분만 렌더링할 만큼의 uv좌표값을 얻게 됨.

    여기에, offset 이라는, 가로 몇번째, 세로 몇번째 프레임으로
    이동할 것인지에 대한 정보가 담긴 vec2 데이터를 vec2(0.28, 0.19) 에 곱해줌으로써,

    몇 번째 프레임으로 이동해서 해당 프레임 영역의 uv좌표값들을
    계산해줄 것인지를 정할 수 있음. 
  */
  fragUV = vec2(uv.x, 1.0 - uv.y) * size + (offset * size);
}